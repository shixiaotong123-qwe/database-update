# Refinery 迁移错误处理机制详解

## 🎯 概述

本文档详细分析 Refinery 项目在迁移出错时的完整错误处理机制，包括错误类型分类、处理流程和最佳实践。

## 🏗️ 错误处理架构

### 错误处理层次结构

```
┌─────────────────────────────────────────────────────────┐
│                    应用程序入口                          │
│                   (main.rs)                            │
└─────────────────┬───────────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────────────┐
│              数据库管理层                                │
│            (database.rs)                               │
│  ┌─────────────────────────────────────────────────┐   │
│  │            迁移执行层                            │   │
│  │       (safe_migrate 方法)                       │   │
│  └─────────────┬───────────────────────────────────┘   │
└────────────────┼───────────────────────────────────────┘
                 │
┌────────────────▼───────────────────────────────────────┐
│              错误处理层                                │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │
│  │ 连接错误     │ │ 迁移错误     │ │ 完整性错误   │      │
│  │ 处理        │ │ 处理        │ │ 处理        │      │
│  └─────────────┘ └─────────────┘ └─────────────┘      │
└────────────────────────────────────────────────────────┘
```

## 🔧 代码分析

### 1. main.rs 中的错误处理

#### 错误分类策略

```rust
// 致命错误 - 立即退出
match database::connect().await {
    Ok(manager) => manager,
    Err(e) => {
        error!("❌ 数据库连接失败: {}", e);
        return Err(e);  // 🚨 立即退出
    }
}

// 迁移错误 - 致命错误
match db_manager.safe_migrate(&database_url).await {
    Ok(_) => info!("✅ Refinery数据库迁移完成"),
    Err(e) => {
        error!("❌ Refinery数据库迁移失败: {}", e);
        return Err(e);  // 🚨 立即退出
    }
}

// 警告错误 - 记录但继续执行
match data::show_data_statistics(db_manager.get_client()).await {
    Ok(_) => info!("✅ 数据统计显示完成"),
    Err(e) => {
        error!("⚠️  数据统计失败: {}", e);
        // 🔄 继续执行，不退出
    }
}
```

#### 错误处理优先级

| 优先级 | 错误类型 | 处理方式 | 影响 |
|--------|----------|----------|------|
| **P0 - 致命** | 数据库连接失败 | 立即退出 | 程序无法运行 |
| **P0 - 致命** | 迁移执行失败 | 立即退出 | 数据库状态不一致 |
| **P0 - 致命** | 表结构验证失败 | 立即退出 | 数据库结构错误 |
| **P1 - 重要** | 数据插入失败 | 立即退出 | 数据不完整 |
| **P2 - 警告** | 统计信息获取失败 | 记录警告，继续 | 影响监控 |
| **P2 - 警告** | 索引状态检查失败 | 记录警告，继续 | 影响性能监控 |

### 2. database.rs 中的错误处理

#### 连接层错误处理

```rust
pub async fn new_with_config(database_url: &str) -> Result<Self> {
    info!("正在使用Refinery连接数据库...");
    
    // 🔌 连接建立错误处理
    let (client, connection) = tokio_postgres::connect(database_url, NoTls)
        .await
        .context("无法连接到数据库")?;  // ← anyhow::Context 提供详细错误信息
    
    // 🧪 连接测试错误处理
    let _row = client.query_one("SELECT 1", &[])
        .await
        .context("数据库连接测试失败")?;  // ← 确保连接可用
    
    Ok(Self { client })
}
```

#### 迁移层错误处理

```rust
pub async fn safe_migrate(&mut self, database_url: &str) -> Result<()> {
    info!("开始执行Refinery数据库迁移...");
    
    // 🔄 多层错误处理策略
    let migration_result = tokio::task::spawn_blocking(move || -> Result<refinery::Report, anyhow::Error> {
        // 1️⃣ URL解析错误
        let db_config = postgres::Config::from_str(&database_url_owned)
            .context("解析数据库URL失败")?;
        
        // 2️⃣ 同步连接建立错误
        let mut postgres_client = db_config.connect(postgres::NoTls)
            .context("创建迁移专用连接失败")?;
        
        // 3️⃣ 迁移执行错误
        let report = embedded::migrations::runner().run(&mut postgres_client)
            .map_err(|e| anyhow::anyhow!("Refinery迁移执行失败: {}", e))?;
        
        Ok(report)
    }).await
    .context("迁移任务执行失败")?      // 4️⃣ 异步任务执行错误
    .context("迁移操作失败")?;        // 5️⃣ 迁移操作级别错误
    
    // ✅ 成功处理
    info!("✅ Refinery数据库迁移完成");
    Ok(())
}
```

### 3. 专门的错误处理方法

#### handle_migration_failure - 迁移失败处理器

```rust
async fn handle_migration_failure(&self) -> Result<()> {
    error!("正在处理Refinery迁移失败...");
    
    // 📊 生成失败报告
    self.generate_failure_report().await?;
    
    // 🔍 检查数据完整性
    self.check_data_integrity().await?;
    
    Ok(())
}
```

#### generate_failure_report - 失败报告生成器

```rust
async fn generate_failure_report(&self) -> Result<()> {
    let report_time = chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC");
    
    // 📋 迁移历史分析
    let migration_history = self.client.query(
        "SELECT version, name, applied_on, checksum 
         FROM refinery_schema_history 
         ORDER BY version DESC",
        &[]
    ).await?;
    
    error!("=== Refinery迁移失败报告 ===");
    error!("时间: {}", report_time);
    error!("迁移历史记录数量: {}", migration_history.len());
    
    // 🔍 显示最近的迁移记录
    for row in migration_history.iter().take(5) {
        let version: i32 = row.get("version");
        let name: String = row.get("name");
        let applied_on: chrono::DateTime<chrono::Utc> = row.get("applied_on");
        error!("  - v{}: {} ({})", version, name, applied_on.format("%Y-%m-%d %H:%M:%S"));
    }
    
    Ok(())
}
```

#### check_data_integrity - 数据完整性检查器

```rust
async fn check_data_integrity(&self) -> Result<()> {
    info!("检查数据完整性...");
    
    let critical_tables = vec!["users", "products", "orders"];
    
    for table in critical_tables {
        // 🔍 表存在性检查
        let exists: bool = self.client.query_one(
            "SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = $1 AND table_schema = 'public'
            ) as exists",
            &[&table]
        ).await?.get("exists");
        
        if exists {
            // 📊 数据量检查
            match self.client.query(&format!("SELECT COUNT(*) as count FROM {}", table), &[]).await {
                Ok(rows) => {
                    let count: i64 = rows[0].get("count");
                    info!("✅ 表 {} 存在，包含 {} 行数据", table, count);
                }
                Err(e) => {
                    warn!("⚠️  无法查询表 {} 的数据量: {}", table, e);
                }
            }
        } else {
            warn!("⚠️  关键表 {} 不存在", table);
        }
    }
    
    Ok(())
}
```

## 🚨 实际错误场景演示

### 场景1: 文件系统不一致错误

```
错误信息: migration V10__测试真实错误 is missing from the filesystem
错误原因: 数据库记录了迁移版本，但文件系统中缺少对应的迁移文件
处理方式: 立即退出，防止状态不一致
```

**实际输出：**
```
2025-09-08T10:05:07.696622Z  INFO postgres::config: NOTICE: relation "refinery_schema_history" already exists, skipping
2025-09-08T10:05:07.698880Z ERROR main: ❌ Refinery数据库迁移失败: 迁移操作失败
Error: 迁移操作失败

Caused by:
    Refinery迁移执行失败: migration V10__测试真实错误 is missing from the filesystem
```

### 场景2: 数据库连接失败错误

```
错误信息: 无法连接到数据库
错误原因: PostgreSQL服务未运行或连接参数错误
处理方式: 立即退出，无法继续执行
```

### 场景3: SQL语法错误

```
错误信息: syntax error at or near "TABL"
错误原因: 迁移文件中包含无效的SQL语法
处理方式: 迁移中止，数据库状态回滚
```

### 场景4: 约束违反错误

```sql
-- 错误示例：引用不存在的表
ALTER TABLE orders ADD CONSTRAINT fk_orders_nonexistent 
FOREIGN KEY (user_id) REFERENCES nonexistent_table(id);

-- 错误信息：relation "nonexistent_table" does not exist
```

## 📊 错误处理流程图

```
开始迁移
    │
    ▼
检查数据库连接 ──❌──► 记录错误 ──► 退出(Code: 1)
    │✅
    ▼
解析迁移文件 ──❌──► 记录错误 ──► 退出(Code: 1)
    │✅
    ▼
执行迁移SQL ──❌──► 生成失败报告 ──► 检查数据完整性 ──► 退出(Code: 1)
    │✅
    ▼
验证结果 ──❌──► 记录警告 ──► 继续执行
    │✅
    ▼
迁移成功 ──► 记录成功日志 ──► 继续后续操作
```

## 🛡️ 错误处理最佳实践

### 1. 预防性措施

#### 迁移前检查清单
```bash
# 1. 数据库连接测试
psql "$DATABASE_URL" -c "SELECT 1;"

# 2. 迁移文件语法检查
for file in migrations/*.sql; do
    echo "检查 $file"
    psql "$DATABASE_URL" -f "$file" --dry-run 2>/dev/null || echo "⚠️ $file 有语法错误"
done

# 3. 干运行测试
refinery migrate -f

# 4. 备份数据库
pg_dump "$DATABASE_URL" > backup_$(date +%Y%m%d_%H%M%S).sql
```

#### 迁移文件编写规范
```sql
-- ✅ 好的做法
-- V001__create_users_table.sql
-- 创建用户表和相关索引

-- 使用条件语句避免重复创建
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL
);

-- 使用条件语句安全创建索引
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);

-- ❌ 避免的做法
-- 没有条件检查的语句
CREATE TABLE users (id SERIAL PRIMARY KEY);  -- 可能导致重复创建错误

-- 直接删除数据
DELETE FROM users WHERE created_at < '2020-01-01';  -- 危险操作
```

### 2. 错误发生时的应急响应

#### 迁移失败恢复流程

```bash
#!/bin/bash
# 迁移失败应急恢复脚本

echo "🚨 迁移失败应急恢复程序"

# 1. 立即备份当前状态
echo "📦 备份当前数据库状态..."
pg_dump "$DATABASE_URL" > emergency_backup_$(date +%Y%m%d_%H%M%S).sql

# 2. 检查迁移状态
echo "🔍 检查迁移状态..."
psql "$DATABASE_URL" -c "
SELECT version, name, applied_on 
FROM refinery_schema_history 
ORDER BY version DESC 
LIMIT 10;"

# 3. 分析错误日志
echo "📋 分析错误原因..."
tail -50 /var/log/application.log | grep -i error

# 4. 决策选项
echo "🎯 恢复选项："
echo "1. 修复迁移文件并重新执行"
echo "2. 手动回滚到上一个稳定版本"
echo "3. 从备份恢复数据库"

read -p "选择恢复方案 (1-3): " choice

case $choice in
    1) echo "修复迁移文件后重新运行 refinery migrate" ;;
    2) echo "手动执行回滚SQL" ;;
    3) echo "从备份恢复：psql \$DATABASE_URL < backup_file.sql" ;;
esac
```

### 3. 监控和告警

#### 迁移监控脚本
```bash
#!/bin/bash
# 迁移状态监控脚本

DATABASE_URL="$1"
ALERT_WEBHOOK="$2"

# 检查迁移状态
LAST_MIGRATION=$(psql "$DATABASE_URL" -tAc "
SELECT MAX(version) FROM refinery_schema_history;
")

MIGRATION_FILES=$(ls migrations/V*.sql | wc -l)

if [ "$MIGRATION_FILES" -gt "$LAST_MIGRATION" ]; then
    PENDING=$((MIGRATION_FILES - LAST_MIGRATION))
    MESSAGE="⚠️ 发现 $PENDING 个待执行的迁移"
    
    # 发送告警
    curl -X POST -H 'Content-type: application/json' \
         --data "{\"text\":\"$MESSAGE\"}" \
         "$ALERT_WEBHOOK"
fi
```

## 🔧 错误处理改进建议

### 1. 增强错误报告

当前项目中 `handle_migration_failure`、`generate_failure_report` 和 `check_data_integrity` 方法存在但未被调用。建议在 `safe_migrate` 方法中集成：

```rust
pub async fn safe_migrate(&mut self, database_url: &str) -> Result<()> {
    // ... 现有代码 ...
    
    match migration_result {
        Ok(report) => {
            info!("✅ Refinery数据库迁移完成");
            // 处理成功结果...
        }
        Err(e) => {
            error!("❌ 迁移失败，启动错误处理流程...");
            
            // 🆕 调用错误处理方法
            if let Err(handle_err) = self.handle_migration_failure().await {
                error!("错误处理器本身发生错误: {}", handle_err);
            }
            
            return Err(e);
        }
    }
    
    Ok(())
}
```

### 2. 添加重试机制

```rust
async fn safe_migrate_with_retry(&mut self, database_url: &str, max_retries: u32) -> Result<()> {
    let mut attempts = 0;
    
    while attempts < max_retries {
        match self.safe_migrate(database_url).await {
            Ok(_) => return Ok(()),
            Err(e) => {
                attempts += 1;
                if attempts < max_retries {
                    warn!("迁移失败，第 {} 次重试 (最大 {} 次): {}", attempts, max_retries, e);
                    tokio::time::sleep(tokio::time::Duration::from_secs(5 * attempts as u64)).await;
                } else {
                    error!("迁移在 {} 次尝试后仍然失败: {}", max_retries, e);
                    return Err(e);
                }
            }
        }
    }
    
    unreachable!()
}
```

### 3. 添加迁移锁机制

```rust
async fn acquire_migration_lock(&self) -> Result<bool> {
    let result = self.client.execute(
        "INSERT INTO migration_lock (id, acquired_at) VALUES (1, NOW()) 
         ON CONFLICT (id) DO NOTHING",
        &[]
    ).await?;
    
    Ok(result > 0)
}

async fn release_migration_lock(&self) -> Result<()> {
    self.client.execute("DELETE FROM migration_lock WHERE id = 1", &[]).await?;
    Ok(())
}
```

## 📚 总结

Refinery 项目具备了完整的错误处理框架：

### ✅ 现有优势
1. **分层错误处理**: 从连接到迁移执行的完整错误处理链
2. **详细错误信息**: 使用 `anyhow::Context` 提供错误上下文
3. **错误分类**: 区分致命错误和警告错误
4. **专用错误处理方法**: 失败报告和数据完整性检查

### 🔧 改进空间
1. **实际调用错误处理方法**: 将现有的错误处理方法集成到主流程中
2. **增加重试机制**: 对临时性错误进行重试
3. **添加监控和告警**: 实时监控迁移状态
4. **增强恢复能力**: 自动恢复和手动恢复选项

这个错误处理机制为生产环境的数据库迁移提供了强有力的保障！
